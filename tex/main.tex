\documentclass[9pt,twoside]{extarticle}
\usepackage{style}

\begin{document}
  \pagestyle{fancy}
  \begin{multicols*}{3}
    \tableofcontents

    \section{Contest}
    \ctitle{sol.cpp}
    \cfile{sol.cpp}

    \ctitle{.vimrc}
    \cfile[raw]{../contest/.vimrc}

    \ctitle{Makefile}
    \cfile[make]{../contest/Makefile}

    \ctitle{test.sh}
    \cfile[bash]{../contest/test.sh}

    \section{Struktury danych}
    \ctitle{Drzewo falkowe}
    \cheader{Opis}{%
      Obsługuje zapytania typu \textit{podaj k-ty najmniejszy na przedziale} itp.~na statycznej tablicy.
      Jeżeli czas albo pamięć są ciasne warto przeskalować liczby.
      Niszczy tablicę.
    }
    \cheader{Czas}{\bigo{\log A}}
    \cfile{../data/wavelet.cpp}

    \ctitle{Ordered set}
    \cheader{Opis}{Alternatywnie można użyć treapa albo trie.}
    \cheader{Stosowanie}{\src{s.find_by_order(k)} i \src{s.order_of_key(k)}.}
    \cheader{Czas}{\bigo{\log n} z dużą stałą.}
    \cfile{../data/pbds.cpp}

    \ctitle{Treap}
    \cheader{Opis}{Randomizowane drzewo binarne.}
    \cheader{Czas}{\bigo{\log n}}
    \cfile{../data/treap.cpp}

    \section{Grafy}
    \subsection{Przepływy}
    \ctitle{Dinic}
    \cheader{Opis}{Znajduje największy przepływ.}
    \cheader{Czas}{\bigo{n^2m}, ale w rzeczywistości szybszy.}
    \cfile{../graph/dinic.cpp}

    \ctitle{MCMF}
    \cheader{Opis}{Znajduje największy przepływ o najmniejszym koszcie.}
    \cheader{Stosowanie}{%
      Jeżeli są ujemne krawędzie, przed pusczeniem \src{flow} w \src{dst} trzeba
      policzyć najkrótsze ścieżki z \src{s} i puścić \src{reduce(t)}.
    }
    \cheader{Czas}{\bigo{Fm \log n}}
    \cfile{../graph/mcmf.cpp}

    \subsubsection{Przepływy z wymaganiami}
    Szukamy przepływu $\leq F$ takiego, że $f_i \geq d_i$ dla każdej krawędzi.
    Tworzymy nowe źródło $s'$ i ujście $t'$.
    Następnie dodajemy krawędzie
    \begin{compactitem}
      \item $(u_i, t', d_i)$, $(s', v_i, d_i)$, $(u_i, v_i, c_i - d_i)$ zamiast $(u_i, v_i, c_i, d_i)$ 
      \item $(t, s, F)$
    \end{compactitem}
    Przepływ spełnia wymagania jeżeli maksymalnie wypełnia wszystkie krawędzie $s'$.

    \subsection{Grafy dwudzielne}
    \ctitle{Matching}
    \cheader{Opis}{Dinic uproszczony do szukania największego skojarzenia.}
    \cheader{Czas}{\bigo{m\sqrt{n}}}
    \cfile{../graph/matching.cpp}

    \subsubsection{Rozszerzone twierdzenie K\"oniga}
    W grafie dwudzielnym zachodzi
    \begin{compactitem}
      \item $\mathrm{nk} = \mathrm{pw}$
      \item $\mathrm{nk} + \mathrm{pk} = n$
      \item $\mathrm{pw} + \mathrm{nw} = n$
    \end{compactitem}
    oraz
    \begin{compactitem}
      \item pw to zbiór wierzchołków na brzegu min-cut
      \item nw to dopełnienie pw
      \item pk to nk z dodanymi pojedynczymi krawędziami każdego nieskojarzonego wierzchołka
    \end{compactitem}

    \subsection{Grafy skierowane}
    \ctitle{SCC}
    \cheader{Opis}{Znajduje silne spójne składowe w kolejności topologicznej.}
    \cheader{Czas}{\bigo{n + m}}
    \cfile{../graph/scc.cpp}

    \section{Matma}
    \subsection{Wielomiany}
    \ctitle{FFT}
    \cheader{Opis}{Mnoży dwa wielomiany o sumarycznej długości $2^{23}$ modulo $998244353$.}
    \cheader{Czas}{\bigo{(n + m) \log (n + m)}}
    \cfile{../math/fft.cpp}

    \subsection{Mnożniki Lagrange'a}
    Jeżeli optymalizujemy $f(x_1, \dots, x_n)$ przy ograniczeniach typu $g_k(x_1, \dots, x_n) = 0$ to
    $x_1, \dots, x_n$ jest ekstremum lokalnym tylko jeżeli gradient $\nabla f(x_1, \dots, x_n)$ jest kombinacją liniową
    gradientów $\nabla g_k(x_1, \dots x_n)$.

    \section{Teksty}
    \ctitle{KMP}
    \cheader{Opis}{Znajduje funkcje prefiksową. Można z niej skonstruować automat w czasie \bigo{nA}.}
    \cheader{Czas}{\bigo{n}}
    \cfile{../string/kmp.cpp}

    \ctitle{Manacher}
    \cheader{Opis}{Znajduje najdłuższy promień palindromiczny w każdym środku.}
    \cheader{Stosowanie}{\src{p[2 * i]} -- środek w $i$, \src{p[2 * i + 1]} -- środek między $i$ a $i + 1$.}
    \cheader{Czas}{\bigo{n}}
    \cfile{../string/manacher.cpp}

    \ctitle{Tablica sufiksowa}
    \cheader{Opis}{%
      Sortuje leksykograficznie wszystkie sufiksy słowa.
      Tablic \src{rnk} można użyć do porównywania leksykograficznie podsłów.
    }
    \cheader{Czas}{\bigo{n \log n}}
    \cfile{../string/sa.cpp}

    \ctitle{Z}
    \cheader{Opis}{Znajduje funkcję Z.}
    \cheader{Czas}{\bigo{n}}
    \cfile{../string/z.cpp}
  \end{multicols*}
\end{document}
